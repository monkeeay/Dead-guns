/*
 * This source file was generated by the Gradle 'init' task
 */
package com.example.roguelike.core;

import javax.swing.JFrame;
import javax.swing.SwingUtilities;
import com.example.roguelike.entities.Player;
import com.example.roguelike.entities.Enemy;
import com.example.roguelike.entities.EnemyType; // Added
import com.example.roguelike.rendering.GameRenderer;
import com.example.roguelike.world.GameMap;
import com.example.roguelike.world.Room;
import com.example.roguelike.items.Item; // Added
import com.example.roguelike.items.ItemType; // Added
import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.List;
import java.util.ArrayList;
import java.util.Ran
import java.util.Iterator

public class GameManager implements KeyListener {

    private Player player;
    private GameRenderer gameRenderer;
    private GameMap gameMap;
    private List<Enemy> enemies;
    private List<Item> itemsOnMap; 
    private List<String> gameMessages; 
    private long lastEnemyDeathTime = 0; 
    private static final int ENEMY_DEATH_PAUSE_MS = 100; 

    private GameState currentGameState; // Added
    private JFrame frame; // Added

    public GameManager(JFrame frame) { // Updated constructor
        this.frame = frame;
        this.currentGameState = GameState.MAIN_MENU;
        // Game objects (player, map, etc.) are initialized in initializeNewGame()
        // GameRenderer is also initialized there or when frame is set.
        // For now, let's ensure gameRenderer is initialized early for main menu drawing
        this.gameRenderer = new GameRenderer(this, null, null, null, null); // Pass this GameManager
        this.gameRenderer.setPreferredSize(new Dimension(800, 600)); // Default size
    }

    private void initializeNewGame() {
        int panelPixelWidth = frame.getContentPane().getWidth(); // Use frame size
        int panelPixelHeight = frame.getContentPane().getHeight();

        this.gameMap = new GameMap(panelPixelWidth, panelPixelHeight);
        this.enemies = new ArrayList<>();
        this.itemsOnMap = new ArrayList<>();
        this.gameMessages = new ArrayList<>();
        this.lastEnemyDeathTime = 0;
        

        if (!this.gameMap.getRooms().isEmpty()) {
            Room firstRoom = this.gameMap.getRooms().get(0);
            int playerTileX = firstRoom.getX() + firstRoom.getWidth() / 2;
            int playerTileY = firstRoom.getY() + firstRoom.getHeight() / 2;
            this.player = new Player(playerTileX, playerTileY);
        } else {
            this.player = new Player(1, 1); 
        }

        spawnEnemies();
        spawnItems();

        // Re-initialize or update GameRenderer with new game data
        if (this.gameRenderer != null) {
            this.gameRenderer.updateGameData(this.gameMap, this.player, this.enemies, this.itemsOnMap);
        } else { // Should not happen if constructor initializes it
            this.gameRenderer = new GameRenderer(this, this.gameMap, this.player, this.enemies, this.itemsOnMap);
            this.gameRenderer.setPreferredSize(new Dimension(panelPixelWidth, panelPixelHeight));
        }
        this.gameRenderer.setGameOver(false); // Reset game over state in renderer
    }



    private void spawnEnemies() {
        if (this.gameMap.getRooms() == null || this.gameMap.getRooms().isEmpty() || this.player == null) {
            return; 
        }
        Random random = new Random();
        int numberOfEnemiesToSpawn = 3 + random.nextInt(3); 

        for (int i = 0; i < numberOfEnemiesToSpawn; i++) {
            Room spawnRoom = this.gameMap.getRooms().get(random.nextInt(this.gameMap.getRooms().size()));
            int ex = spawnRoom.getX() + random.nextInt(spawnRoom.getWidth());
            int ey = spawnRoom.getY() + random.nextInt(spawnRoom.getHeight());

            if (this.gameMap.isWalkable(ex, ey) && (ex != this.player.getX() || ey != this.player.getY())) {
                EnemyType newEnemyType = EnemyType.values()[random.nextInt(EnemyType.values().length)];
                this.enemies.add(new Enemy(ex, ey, random.nextLong(), this.player, newEnemyType));
            }
        }
    }

    private void spawnItems() {
        if (this.gameMap.getRooms() == null || this.gameMap.getRooms().isEmpty() || this.player == null) {
            return;
        }
        Random random = new Random();
        int numberOfItemsToSpawn = 2 + random.nextInt(2); 


        for (int i = 0; i < numberOfItemsToSpawn; i++) {
            Room spawnRoom = this.gameMap.getRooms().get(random.nextInt(this.gameMap.getRooms().size()));
            int ix = spawnRoom.getX() + random.nextInt(spawnRoom.getWidth());
            int iy = spawnRoom.getY() + random.nextInt(spawnRoom.getHeight());

            boolean positionOccupied = (ix == this.player.getX() && iy == this.player.getY());
            if (positionOccupied) continue; 


            for (Enemy enemy : enemies) {
                if (enemy.getX() == ix && enemy.getY() == iy) {
                    positionOccupied = true;
                    break;
                }
            }
            if (positionOccupied) continue; 


            if (this.gameMap.isWalkable(ix, iy)) {
                ItemType itemType = ItemType.values()[random.nextInt(ItemType.values().length)];
                this.itemsOnMap.add(new Item(itemType, ix, iy));
            }
        }
    }

    public void startGameLoop() {
        while (true) { 
            if (currentGameState == GameState.PLAYING) {
                if (lastEnemyDeathTime > 0 && System.currentTimeMillis() - lastEnemyDeathTime < ENEMY_DEATH_PAUSE_MS) {
                    gameRenderer.repaint(); 
                    try { Thread.sleep(16); } catch (InterruptedException e) { Thread.currentThread().interrupt(); break; }
                    continue; 
                } else {
                    lastEnemyDeathTime = 0; 
                }

                player.update(gameMap);
                for (Enemy enemy : enemies) {
                    enemy.update(gameMap);
                }

                if (!gameMessages.isEmpty()) {
                    for (String message : gameMessages) {
                        System.out.println(message); 
                    }
                    gameMessages.clear();
                }
                
                if (!player.isAlive()) {
                    System.out.println("Game Over!");
                    System.out.println("SFX: Player_Dies"); 
                    currentGameState = GameState.GAME_OVER; 
                    // gameRenderer.setGameOver(true); // GameRenderer will check state
                }

                boolean enemyDiedThisFrame = false;
                Iterator<Enemy> enemyIterator = enemies.iterator();
                while(enemyIterator.hasNext()){
                    Enemy enemy = enemyIterator.next();
                    if (!enemy.isAlive()) {
                        gameMessages.add("An " + enemy.getType().toString().toLowerCase() + " has been defeated! You gain " + enemy.getExperienceValue() + " XP.");
                        player.addExperience(enemy.getExperienceValue(), gameMessages);
                        System.out.println("SFX: Enemy_Dies"); 
                        enemyDiedThisFrame = true;
                        enemyIterator.remove();
                    }
                }
                if (enemyDiedThisFrame && lastEnemyDeathTime == 0) {
                     lastEnemyDeathTime = System.currentTimeMillis();
                }
            } else if (currentGameState == GameState.MAIN_MENU) {
                // Main menu logic (mostly input handling)
            } else if (currentGameState == GameState.GAME_OVER) {
                // Game over logic (mostly input handling)
            }
            
            if (gameRenderer != null) gameRenderer.repaint();

            try {
                Thread.sleep(16); 
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Roguelike Adventure"); // Updated title
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            GameManager mainGame = new GameManager(frame); // Pass frame
            // mainGame.setFrame(frame); // Alternative if using setter
            frame.add(mainGame.gameRenderer); 
            frame.pack(); 
            frame.setLocationRelativeTo(null); 
            frame.setVisible(true);

            frame.addKeyListener(mainGame); 
            frame.setFocusable(true); 
            frame.requestFocusInWindow(); 

            new Thread(mainGame::startGameLoop).start(); 
        });
    }

    public Player getPlayer() { return player; } // Added getter
    public GameState getCurrentGameState() { return currentGameState; } // Added getter
    public JFrame getFrame() { return frame; } // Added getter



        int keyCode = e.getKeyCode();

        if (currentGameState == GameState.PLAYING) {
            if (!player.isAlive()) return; // Don't process game input if player is dead but state not yet GAME_OVER


            switch (keyCode) {
                case KeyEvent.VK_UP:
                case KeyEvent.VK_W:
                    player.move(0, -1, gameMap, this.enemies, this.gameMessages); 
                    break;
                case KeyEvent.VK_DOWN:
                case KeyEvent.VK_S:
                    player.move(0, 1, gameMap, this.enemies, this.gameMessages);  
                    break;
                case KeyEvent.VK_LEFT:
                case KeyEvent.VK_A:
                    player.move(-1, 0, gameMap, this.enemies, this.gameMessages); 
                    break;
                case KeyEvent.VK_RIGHT:
                case KeyEvent.VK_D:
                    player.move(1, 0, gameMap, this.enemies, this.gameMessages);  
                    break;
                case KeyEvent.VK_H: 
                    player.useHealthPotion(gameMessages);

                    break;
            }
            // Item Pickup Logic (after movement or action)
            Iterator<Item> itemIterator = itemsOnMap.iterator();
            while (itemIterator.hasNext()) {
                Item item = itemIterator.next();
                if (item.getX() == player.getX() && item.getY() == player.getY()) {
                    player.pickUpItem(item, gameMessages);
                    itemIterator.remove(); 
                    break; 
                }
            }

        } else if (currentGameState == GameState.MAIN_MENU) {
            if (keyCode == KeyEvent.VK_ENTER || keyCode == KeyEvent.VK_S) {
                initializeNewGame();
                currentGameState = GameState.PLAYING;
            } else if (keyCode == KeyEvent.VK_ESCAPE || keyCode == KeyEvent.VK_X) {
                System.exit(0);
            }
        } else if (currentGameState == GameState.GAME_OVER) {
            if (keyCode == KeyEvent.VK_ENTER || keyCode == KeyEvent.VK_R) {
                initializeNewGame();
                currentGameState = GameState.PLAYING;
            } else if (keyCode == KeyEvent.VK_ESCAPE || keyCode == KeyEvent.VK_M) {
                currentGameState = GameState.MAIN_MENU;
            }
        }

    }

    @Override
    public void keyReleased(KeyEvent e) {
        // Not used
    }
}
