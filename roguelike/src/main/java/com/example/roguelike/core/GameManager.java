/*
 * This source file was generated by the Gradle 'init' task
 */
package com.example.roguelike.core;

import javax.swing.JFrame;
import javax.swing.SwingUtilities;
import com.example.roguelike.entities.Player;
import com.example.roguelike.entities.Enemy;
import com.example.roguelike.entities.EnemyType; // Added
import com.example.roguelike.rendering.GameRenderer;
import com.example.roguelike.world.GameMap;
import com.example.roguelike.world.Room;
import com.example.roguelike.items.Item; // Added
import com.example.roguelike.items.ItemType; // Added
import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.List;
import java.util.ArrayList;
import java.util.Random;
import java.util.Iterator;

public class GameManager implements KeyListener {

    private Player player;
    private GameRenderer gameRenderer;
    private GameMap gameMap;
    private List<Enemy> enemies;
    private List<Item> itemsOnMap; // Added
    private List<String> gameMessages; // Added

    public GameManager() {
        int panelPixelWidth = 800;
        int panelPixelHeight = 600;

        this.gameMap = new GameMap(panelPixelWidth, panelPixelHeight);
        this.enemies = new ArrayList<>();
        this.itemsOnMap = new ArrayList<>(); // Initialize items list
        this.gameMessages = new ArrayList<>(); // Initialize messages list
        
        // Place player
        if (!this.gameMap.getRooms().isEmpty()) {
            Room firstRoom = this.gameMap.getRooms().get(0);
            int playerTileX = firstRoom.getX() + firstRoom.getWidth() / 2;
            int playerTileY = firstRoom.getY() + firstRoom.getHeight() / 2;
            this.player = new Player(playerTileX, playerTileY);
        } else {
            this.player = new Player(1, 1); 
        }

        // Spawn enemies
        spawnEnemies();
        // Spawn items
        spawnItems();

        this.gameRenderer = new GameRenderer(this.gameMap, this.player, this.enemies, this.itemsOnMap); // Pass items
        this.gameRenderer.setPreferredSize(new Dimension(panelPixelWidth, panelPixelHeight));
    }

    private void spawnEnemies() {
        if (this.gameMap.getRooms() == null || this.gameMap.getRooms().isEmpty() || this.player == null) {
            return; 
        }
        Random random = new Random();
        int numberOfEnemiesToSpawn = 3 + random.nextInt(3); 

        for (int i = 0; i < numberOfEnemiesToSpawn; i++) {
            Room spawnRoom = this.gameMap.getRooms().get(random.nextInt(this.gameMap.getRooms().size()));
            int ex = spawnRoom.getX() + random.nextInt(spawnRoom.getWidth());
            int ey = spawnRoom.getY() + random.nextInt(spawnRoom.getHeight());

            if (this.gameMap.isWalkable(ex, ey) && (ex != this.player.getX() || ey != this.player.getY())) {
                EnemyType newEnemyType = EnemyType.values()[random.nextInt(EnemyType.values().length)];
                this.enemies.add(new Enemy(ex, ey, random.nextLong(), this.player, newEnemyType));
            }
        }
    }

    private void spawnItems() {
        if (this.gameMap.getRooms() == null || this.gameMap.getRooms().isEmpty() || this.player == null) {
            return;
        }
        Random random = new Random();
        int numberOfItemsToSpawn = 2 + random.nextInt(2); // 2-3 items

        for (int i = 0; i < numberOfItemsToSpawn; i++) {
            Room spawnRoom = this.gameMap.getRooms().get(random.nextInt(this.gameMap.getRooms().size()));
            int ix = spawnRoom.getX() + random.nextInt(spawnRoom.getWidth());
            int iy = spawnRoom.getY() + random.nextInt(spawnRoom.getHeight());

            boolean positionOccupied = (ix == this.player.getX() && iy == this.player.getY());
            if (positionOccupied) continue; // Don't spawn on player

            for (Enemy enemy : enemies) {
                if (enemy.getX() == ix && enemy.getY() == iy) {
                    positionOccupied = true;
                    break;
                }
            }
            if (positionOccupied) continue; // Don't spawn on enemy

            if (this.gameMap.isWalkable(ix, iy)) {
                ItemType itemType = ItemType.values()[random.nextInt(ItemType.values().length)];
                this.itemsOnMap.add(new Item(itemType, ix, iy));
            }
        }
    }

    public void startGameLoop() {
        while (true) {
            // 1. Update player and enemies
            player.update(gameMap);
            for (Enemy enemy : enemies) {
                enemy.update(gameMap);
            }

            // 2. Handle game messages (pickup, etc.)
            if (!gameMessages.isEmpty()) {
                for (String message : gameMessages) {
                    System.out.println(message); // Print to console for now
                }
                gameMessages.clear();
            }
            
            // 3. Check for player death
            if (!player.isAlive()) {
                System.out.println("Game Over!");
                gameRenderer.setGameOver(true); // Notify renderer
                gameRenderer.repaint(); // Repaint to show game over message
                break; // Stop the game loop
            }

            // 3. Remove dead enemies and grant XP
            enemies.removeIf(enemy -> {
                if (!enemy.isAlive()) {
                    gameMessages.add("An " + enemy.getType().toString().toLowerCase() + " has been defeated! You gain " + enemy.getExperienceValue() + " XP.");
                    player.addExperience(enemy.getExperienceValue(), gameMessages);
                    return true; // Remove if not alive
                }
                return false;
            });

            // 4. Repaint the game
            // This aligns with the simpler example structure from the prompt.
            // Complex game state logic (like health checks, enemy AI) was present in the
            // original Main.java but the refactor prompt points to a simpler GameManager.

            gameRenderer.repaint();

            try {
                Thread.sleep(16); // ~60 FPS
            } catch (InterruptedException e) {
                System.err.println("Game loop interrupted");
                Thread.currentThread().interrupt();
                break;
            }
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Roguelike Game");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            GameManager mainGame = new GameManager(); 
            frame.add(mainGame.gameRenderer); 
            frame.pack(); 
            frame.setLocationRelativeTo(null); 
            frame.setVisible(true);

            frame.addKeyListener(mainGame); 
            frame.setFocusable(true); 
            frame.requestFocusInWindow(); 

            new Thread(mainGame::startGameLoop).start(); 
        });
    }

    @Override
    public void keyTyped(KeyEvent e) {
        // Not used
    }

    @Override
    public void keyPressed(KeyEvent e) {
        // The prompt example for GameManager uses player.getHealth() > 0,
        // but the simplified game loop doesn't update health or have enemies.
        // For now, allow movement regardless of health for simplicity.
        // if (player.getHealth() > 0) { 
            int keyCode = e.getKeyCode();
            switch (keyCode) {
                case KeyEvent.VK_UP:
                case KeyEvent.VK_W:
                    player.move(0, -1, gameMap, this.enemies, this.gameMessages); 
                    break;
                case KeyEvent.VK_DOWN:
                case KeyEvent.VK_S:
                    player.move(0, 1, gameMap, this.enemies, this.gameMessages);  
                    break;
                case KeyEvent.VK_LEFT:
                case KeyEvent.VK_A:
                    player.move(-1, 0, gameMap, this.enemies, this.gameMessages); 
                    break;
                case KeyEvent.VK_RIGHT:
                case KeyEvent.VK_D:
                    player.move(1, 0, gameMap, this.enemies, this.gameMessages);  
                    break;
                case KeyEvent.VK_H: // Use Health Potion
                    player.useHealthPotion(gameMessages);
                    // gameRenderer.repaint(); // Repaint handled by main loop
                    break;
            }
            // Item Pickup Logic (after movement or action)
            Iterator<Item> itemIterator = itemsOnMap.iterator();
            while (itemIterator.hasNext()) {
                Item item = itemIterator.next();
                if (item.getX() == player.getX() && item.getY() == player.getY()) {
                    player.pickUpItem(item, gameMessages);
                    itemIterator.remove(); 
                    break; 
                }
            }
        // }
    }

    @Override
    public void keyReleased(KeyEvent e) {
        // Not used
    }
}
